<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Control Systems Guide</title>
    <style>
        :root {
            --primary: #2563eb;
            --secondary: #475569;
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --accent-red: #ef4444;
            --accent-green: #22c55e;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1, h2, h3 { color: #0f172a; }
        
        /* Grid Layout for Cards */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            border-left: 5px solid var(--primary);
            transition: transform 0.2s;
        }

        .card:hover { transform: translateY(-5px); }

        .tag {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .tag.core { background: #e0f2fe; color: #0369a1; }
        .tag.pros { background: #dcfce7; color: #15803d; }
        .tag.cons { background: #fee2e2; color: #b91c1c; }

        /* Simulation Section Styling */
        .sim-container {
            background: #1e293b;
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            background: #0f172a;
            border-radius: 8px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        button:hover { background: #1d4ed8; }
        button.active { background: var(--accent-green); box-shadow: 0 0 10px var(--accent-green); }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255,255,255,0.1);
            padding: 5px 15px;
            border-radius: 20px;
        }
        
        .sim-info {
            margin-top: 10px;
            font-family: monospace;
            color: #94a3b8;
        }

    </style>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

<div class="container">

    <header style="text-align: center; margin-bottom: 40px;">
        <h1>Control Systems Interactive Guide</h1>
        <p>Explore the physics, pros, and cons of different control algorithms.</p>
    </header>

    <section>
        <h2>Interactive Lab 1: The Levitation Chamber (1D Control)</h2>
        <p>Try to keep the yellow block at the green target line while gravity pulls it down. Add "Wind" to see how they react to external force.</p>
        
        <div class="sim-container">
            <canvas id="sim1Canvas" width="800" height="300"></canvas>
            <div class="sim-info" id="sim1Stats">Error: 0.00 | Output: 0%</div>
            
            <div class="controls">
                <button onclick="setSim1Mode('bangbang')" id="btn-bang">Bang-Bang</button>
                <button onclick="setSim1Mode('pid')" id="btn-pid">PID</button>
                <button onclick="setSim1Mode('smc')" id="btn-smc">Sliding Mode (SMC)</button>
                
                <div class="slider-group">
                    <label>Disturbance (Wind):</label>
                    <input type="range" min="-5" max="5" value="0" id="windSlider">
                </div>
            </div>
            <p style="font-size: 0.9rem; margin-top:10px; opacity: 0.8;" id="sim1Desc">
                Select a controller to start.
            </p>
        </div>
    </section>

    <hr>

    <section>
        <h2>Controller Knowledge Base</h2>
        <div class="grid">
            
            <div class="card" style="border-left-color: #ef4444;">
                <h3>1. Bang-Bang / Hysteresis</h3>
                <div class="tag core">Core: "All or Nothing"</div>
                <p><strong>Logic:</strong> If too low &rarr; Full ON. If too high &rarr; Full OFF.</p>
                <p><strong>Example:</strong> Heaters, Fridges.</p>
                <div class="tag pros">Pros</div>
                <ul><li>Simplest to code</li><li>Cheap hardware (Relays)</li></ul>
                <div class="tag cons">Cons</div>
                <ul><li>Jerky/Oscillating</li><li>Wears out parts</li></ul>
            </div>

            <div class="card" style="border-left-color: #2563eb;">
                <h3>2. PID (Error Based)</h3>
                <div class="tag core">Core: "Reactive Math"</div>
                <p><strong>Logic:</strong> Sum of Proportional (Present), Integral (Past), Derivative (Future).</p>
                <p><strong>Example:</strong> Drones, Cruise Control.</p>
                <div class="tag pros">Pros</div>
                <ul><li>Industry Standard (90%)</li><li>Smooth output</li></ul>
                <div class="tag cons">Cons</div>
                <ul><li>Blind to physics</li><li>Reactive (lags)</li></ul>
            </div>

            <div class="card" style="border-left-color: #eab308;">
                <h3>3. Pure Pursuit (Geometric)</h3>
                <div class="tag core">Core: "The Dog Chase"</div>
                <p><strong>Logic:</strong> Look at a point ahead on the path and steer towards it.</p>
                <p><strong>Example:</strong> Agricultural Rovers, AGVs.</p>
                <div class="tag pros">Pros</div>
                <ul><li>Very smooth</li><li>Robust to GPS noise</li></ul>
                <div class="tag cons">Cons</div>
                <ul><li>Cuts corners</li><li>Sacrifices accuracy for smoothness</li></ul>
            </div>

            <div class="card" style="border-left-color: #a855f7;">
                <h3>4. MPC (Predictive)</h3>
                <div class="tag core">Core: "The Chess Player"</div>
                <p><strong>Logic:</strong> Simulate 50 futures, pick the best one.</p>
                <p><strong>Example:</strong> SpaceX Landing, Tesla Autopilot.</p>
                <div class="tag pros">Pros</div>
                <ul><li>Handles constraints (Walls, Speed limits)</li></ul>
                <div class="tag cons">Cons</div>
                <ul><li>Computationally heavy</li><li>Hard to implement</li></ul>
            </div>

             <div class="card" style="border-left-color: #f97316;">
                <h3>5. Sliding Mode (SMC)</h3>
                <div class="tag core">Core: "The Brute Force"</div>
                <p><strong>Logic:</strong> Force system onto a path using aggressive switching.</p>
                <p><strong>Example:</strong> ABS Brakes, Underwater Robots.</p>
                <div class="tag pros">Pros</div>
                <ul><li>Invincible (Robust to model errors)</li></ul>
                <div class="tag cons">Cons</div>
                <ul><li>Chattering (High vibration)</li></ul>
            </div>

        </div>
    </section>

    <section>
        <h2>Interactive Lab 2: The Geometric Rover (2D)</h2>
        <p>Demonstration of <strong>Pure Pursuit</strong>. The rover attempts to follow the white path. Change the "Look Ahead" distance to see how it affects cornering.</p>
        
        <div class="sim-container">
            <canvas id="sim2Canvas" width="800" height="400"></canvas>
            
            <div class="controls">
                <div class="slider-group">
                    <label>Look Ahead Distance ($l_d$):</label>
                    <input type="range" min="10" max="150" value="60" id="lookAheadSlider">
                    <span id="lookAheadVal">60</span>
                </div>
                <div class="slider-group">
                    <label>Speed:</label>
                    <input type="range" min="1" max="10" value="3" id="speedSlider">
                </div>
                <button onclick="resetSim2()">Reset Rover</button>
            </div>
        </div>
    </section>

</div>

<script>
    /* =========================================
       LAB 1: 1D VERTICAL CONTROL (Drone/Heater)
       ========================================= */
    const cvs1 = document.getElementById('sim1Canvas');
    const ctx1 = cvs1.getContext('2d');
    
    // System State
    let drone = { y: 250, vy: 0, mass: 1 };
    let targetY = 150;
    let gravity = 0.2;
    let sim1Mode = 'pid'; // bangbang, pid, smc
    
    // Controller Memory
    let pidState = { integral: 0, prevError: 0 };
    
    // PID Gains
    const Kp = 0.08;
    const Ki = 0.001;
    const Kd = 1.5;

    // Simulation Loop
    function updateSim1() {
        ctx1.clearRect(0, 0, cvs1.width, cvs1.height);

        // 1. Draw Target Line
        ctx1.strokeStyle = '#22c55e';
        ctx1.setLineDash([10, 5]);
        ctx1.lineWidth = 2;
        ctx1.beginPath();
        ctx1.moveTo(0, targetY);
        ctx1.lineTo(cvs1.width, targetY);
        ctx1.stroke();
        ctx1.setLineDash([]);
        ctx1.fillStyle = '#22c55e';
        ctx1.fillText("Target Setpoint", 10, targetY - 10);

        // 2. Physics & Control
        let error = (targetY - drone.y); // Negative if drone is below target (y increases downwards)
        // Wait, canvas Y increases down. 
        // Let's define Error = TargetY - DroneY.
        // If Drone (200) > Target (150), Error is -50 (Needs upward force).
        // Wait, "Up" in canvas is negative Y.
        
        // Let's fix coordinates for logic:
        // Position P. Target T.
        // Error = T - P.
        // If P (200) is below T (150), Error is -50.
        // We need force UP (Negative Y).
        
        let force = 0;
        let controlOut = 0; // For display text

        // External Disturbance
        let wind = parseFloat(document.getElementById('windSlider').value);
        
        // --- CONTROLLER LOGIC ---
        if (sim1Mode === 'bangbang') {
            // Hysteresis: If below target, Full Force Up. If above, Gravity only.
            // Remember: Y is larger at bottom. 
            if (drone.y > targetY) {
                force = -0.8; // Full thrust up
                controlOut = 100;
            } else {
                force = 0; // Off
                controlOut = 0;
            }
            document.getElementById('sim1Desc').innerText = "Bang-Bang: Full Thrust if below line, Zero if above. Result: Oscillation.";
        
        } else if (sim1Mode === 'pid') {
            // Error calculation
            let err = targetY - drone.y; // e.g. 150 - 250 = -100.
            
            // For canvas, "Up" force needs to be negative.
            // So if we are at 250 (low), target 150 (high), we want Negative force.
            // Our error is -100. So positive Kp makes force negative? No.
            // Let's multiply by Kp. -100 * 0.1 = -10. Correct direction (Up).
            
            pidState.integral += err;
            let derivative = err - pidState.prevError;
            
            force = (Kp * err) + (Ki * pidState.integral) + (Kd * derivative);
            pidState.prevError = err;
            
            controlOut = Math.round(force * 100) / 100;
            document.getElementById('sim1Desc').innerText = "PID: Calculates force based on distance, accumulation, and speed. Result: Smooth hovering.";

        } else if (sim1Mode === 'smc') {
            // Sliding Mode Control
            // Surface s = error_dot + lambda * error
            // u = -K * sign(s)
            
            let err = targetY - drone.y;
            let err_dot = -drone.vy; // approx derivative of error
            let lambda = 0.5;
            let s = err_dot + lambda * err;
            
            // Switching function
            if (s < 0) force = -1.0; // Max thrust
            else force = 0.5; // Downward push (or less thrust)
            
            controlOut = (s < 0) ? "MAX" : "MIN";
            document.getElementById('sim1Desc').innerText = "SMC: Forces system onto a 'sliding surface' via aggressive switching. Result: 'Chattering' (vibration) but robust.";
        }

        // Apply Physics
        drone.vy += gravity;      // Gravity pulls down (positive Y)
        drone.vy += force;        // Control force
        drone.vy += (wind * 0.05);// Wind
        drone.vy *= 0.95;         // Air friction (Damping)
        drone.y += drone.vy;

        // Floor/Ceiling collision
        if(drone.y > cvs1.height - 20) { drone.y = cvs1.height - 20; drone.vy *= -0.5; }
        if(drone.y < 20) { drone.y = 20; drone.vy = 0; }

        // 3. Draw Drone
        ctx1.fillStyle = '#facc15';
        ctx1.shadowBlur = 10;
        ctx1.shadowColor = 'rgba(250, 204, 21, 0.5)';
        ctx1.fillRect(380, drone.y - 15, 40, 30);
        ctx1.shadowBlur = 0;
        
        // Thruster visual
        if(force < -0.1) {
            ctx1.fillStyle = '#ef4444';
            ctx1.beginPath();
            ctx1.moveTo(390, drone.y + 15);
            ctx1.lineTo(400, drone.y + 15 + Math.abs(force)*20);
            ctx1.lineTo(410, drone.y + 15);
            ctx1.fill();
        }

        // Stats
        document.getElementById('sim1Stats').innerText = `Height: ${Math.round(cvs1.height - drone.y)} | Control Output: ${controlOut}`;

        requestAnimationFrame(updateSim1);
    }

    function setSim1Mode(mode) {
        sim1Mode = mode;
        // Reset states
        pidState = { integral: 0, prevError: 0 };
        // Reset button styles
        document.querySelectorAll('#sim1Canvas + div + div button').forEach(b => b.classList.remove('active'));
        document.getElementById('btn-' + mode).classList.add('active');
    }
    
    // Init Sim 1
    setSim1Mode('pid');
    requestAnimationFrame(updateSim1);


    /* =========================================
       LAB 2: 2D GEOMETRIC (Rover Path)
       ========================================= */
    const cvs2 = document.getElementById('sim2Canvas');
    const ctx2 = cvs2.getContext('2d');
    
    let rover = { x: 50, y: 350, heading: 0, speed: 2 };
    
    // Generate Path (Sine wave)
    let pathPoints = [];
    for(let i=0; i<800; i+=5) {
        pathPoints.push({
            x: i,
            y: 200 + 100 * Math.sin(i * 0.02)
        });
    }

    function dist(p1, p2) {
        return Math.sqrt( (p1.x-p2.x)**2 + (p1.y-p2.y)**2 );
    }

    function updateSim2() {
        ctx2.clearRect(0, 0, cvs2.width, cvs2.height);

        // Inputs
        let lookAheadDist = parseInt(document.getElementById('lookAheadSlider').value);
        let speed = parseInt(document.getElementById('speedSlider').value);
        document.getElementById('lookAheadVal').innerText = lookAheadDist;

        // 1. Draw Path
        ctx2.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx2.lineWidth = 4;
        ctx2.beginPath();
        ctx2.moveTo(pathPoints[0].x, pathPoints[0].y);
        for(let p of pathPoints) ctx2.lineTo(p.x, p.y);
        ctx2.stroke();

        // 2. Pure Pursuit Logic
        // Find closest point on path
        let closestIdx = 0;
        let minDist = 99999;
        for(let i=0; i<pathPoints.length; i++) {
            let d = dist(rover, pathPoints[i]);
            if(d < minDist) { minDist = d; closestIdx = i; }
        }

        // Find Lookahead point (search forward from closest point)
        let lookAheadPoint = pathPoints[pathPoints.length-1];
        for(let i=closestIdx; i<pathPoints.length; i++) {
            let d = dist(rover, pathPoints[i]);
            if(d >= lookAheadDist) {
                lookAheadPoint = pathPoints[i];
                break;
            }
        }

        // Calculate Steering
        // Angle to lookahead point
        let angleToTarget = Math.atan2(lookAheadPoint.y - rover.y, lookAheadPoint.x - rover.x);
        
        // Simple steering model (Heading turns towards target)
        let alpha = angleToTarget - rover.heading;
        // Normalize angle
        while (alpha > Math.PI) alpha -= 2 * Math.PI;
        while (alpha < -Math.PI) alpha += 2 * Math.PI;
        
        rover.heading += alpha * 0.1; // Turning rate limit
        
        // Move Rover
        rover.x += Math.cos(rover.heading) * speed;
        rover.y += Math.sin(rover.heading) * speed;

        // Loop canvas
        if(rover.x > cvs2.width) { rover.x = 0; rover.y = 200; rover.heading = 0; }

        // 3. Draw Visuals
        
        // Lookahead Line
        ctx2.strokeStyle = 'yellow';
        ctx2.lineWidth = 1;
        ctx2.setLineDash([5, 5]);
        ctx2.beginPath();
        ctx2.moveTo(rover.x, rover.y);
        ctx2.lineTo(lookAheadPoint.x, lookAheadPoint.y);
        ctx2.stroke();
        ctx2.setLineDash([]);
        
        // Target Dot
        ctx2.fillStyle = 'yellow';
        ctx2.beginPath();
        ctx2.arc(lookAheadPoint.x, lookAheadPoint.y, 5, 0, Math.PI*2);
        ctx2.fill();

        // Rover
        ctx2.save();
        ctx2.translate(rover.x, rover.y);
        ctx2.rotate(rover.heading);
        ctx2.fillStyle = '#3b82f6';
        ctx2.fillRect(-15, -10, 30, 20); // Car body
        ctx2.fillStyle = '#93c5fd';
        ctx2.fillRect(5, -8, 10, 16); // Windshield
        ctx2.restore();

        requestAnimationFrame(updateSim2);
    }

    function resetSim2() {
        rover.x = 0;
        rover.y = 200;
        rover.heading = 0;
    }

    requestAnimationFrame(updateSim2);

</script>

</body>
</html>
