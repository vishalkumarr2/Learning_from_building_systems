<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Explainer: How Browsers Run Code</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: "Warm Neutral Harmony" -->
    <!-- Application Structure Plan: The application is structured into four main, scroll-navigated thematic sections: 1) The Big Picture (Browser Architecture), 2) The Twin Engines (Rendering & JS), 3) The Bridge (DOM & APIs), and 4) The Execution Flow (Event Loop & TypeScript). This non-linear, thematic structure was chosen over the report's linear format to allow users to explore concepts based on interest. Key interactions include hover-to-highlight diagrams for the browser architecture and JIT pipeline, and clickable tabs for the Event Loop, making complex systems digestible and explorable. This design prioritizes user-driven learning and synthesis of interconnected concepts. A new collapsible section contains the full detailed article for reference. -->
    <!-- Visualization & Content Choices: 
        - Report Info: Multi-process architecture -> Goal: Organize/Inform -> Viz: Interactive HTML/CSS diagram -> Interaction: Hover to highlight processes and see descriptions -> Justification: Visually demonstrates isolation and roles more effectively than text. -> Method: HTML/Tailwind + JS.
        - Report Info: JIT Compilation Pipeline -> Goal: Change/Process -> Viz: Interactive HTML/CSS flowchart -> Interaction: Click steps to reveal detailed explanations -> Justification: Breaks down a complex, multi-stage process into understandable steps. -> Method: HTML/Tailwind + JS.
        - Report Info: Event Loop (Macro/Microtasks) -> Goal: Organize/Change -> Viz: Tabbed content with animated diagram -> Interaction: User clicks tabs to switch between Macrotask and Microtask explanations, triggering a simple visual flow -> Justification: Clarifies the priority and execution flow which is difficult to grasp from static text. -> Method: HTML/Tailwind + JS.
        - Report Info: Memory Heaps (V8/Blink) -> Goal: Compare/Relationships -> Viz: Side-by-side comparison table with icons -> Interaction: Static, clear comparison -> Justification: A simple table is the most direct way to compare the two heaps and their distinct responsibilities. -> Method: HTML/Tailwind.
        - Report Info: Full Article Text -> Goal: Inform/Reference -> Viz: Collapsible accordion sections -> Interaction: Click to expand/collapse -> Justification: Integrates detailed text without cluttering the primary interactive view, providing deep-dive context on demand. -> Method: HTML/Tailwind + JS.
        - CONFIRMATION: NO SVG graphics used. NO Mermaid JS used.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FDFBF8; /* Warm Neutral Main BG */
            color: #4A4A4A;
        }
        .nav-link {
            transition: all 0.3s ease;
            border-bottom: 2px solid transparent;
        }
        .nav-link.active, .nav-link:hover {
            color: #D97706; /* Amber-600 Accent */
            border-bottom-color: #D97706;
        }
        .section-card {
            background-color: #FFFFFF;
            border: 1px solid #F3F4F6; /* Gray-100 */
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.05), 0 2px 4px -2px rgb(0 0 0 / 0.05);
        }
        .interactive-box {
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        .interactive-box.highlight {
            border-color: #F59E0B; /* Amber-500 */
            background-color: #FFFBEB; /* Amber-50 */
            transform: scale(1.02);
        }
        .jit-step {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .jit-step.active {
            background-color: #D97706;
            color: white;
        }
        .tab-button.active {
            background-color: #D97706;
            color: white;
        }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out;
        }
        .accordion-button svg {
            transition: transform 0.3s ease;
        }
        .accordion-button.open svg {
            transform: rotate(90deg);
        }
        .prose h2 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-top: 2rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.5rem;
        }
        .prose h3 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }
        .prose p, .prose ul, .prose ol {
            line-height: 1.75;
            margin-bottom: 1rem;
        }
        .prose ul {
            list-style-type: disc;
            padding-left: 1.5rem;
        }
        .prose strong {
            color: #111827;
        }
        .prose code {
            background-color: #F3F4F6;
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            font-family: monospace;
            color: #D97706;
        }
        .prose table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
        }
        .prose th, .prose td {
            border: 1px solid #e5e7eb;
            padding: 0.75rem;
            text-align: left;
        }
        .prose th {
            background-color: #f9fafb;
            font-weight: 600;
        }
    </style>
</head>
<body class="antialiased">

    <!-- Header & Navigation -->
    <header class="sticky top-0 z-50 bg-white/80 backdrop-blur-lg shadow-sm">
        <div class="container mx-auto px-4">
            <div class="flex items-center justify-between h-16">
                <h1 class="text-xl font-bold text-gray-800">Browser Internals: An Interactive Guide</h1>
                <nav class="hidden md:flex items-center space-x-8">
                    <a href="#architecture" class="nav-link font-medium text-gray-600 pb-1">Architecture</a>
                    <a href="#engines" class="nav-link font-medium text-gray-600 pb-1">The Engines</a>
                    <a href="#bridge" class="nav-link font-medium text-gray-600 pb-1">The DOM Bridge</a>
                    <a href="#execution" class="nav-link font-medium text-gray-600 pb-1">Execution Flow</a>
                    <a href="#detailed-view" class="nav-link font-medium text-gray-600 pb-1">Detailed View</a>
                </nav>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto px-4 py-8 md:py-12">

        <!-- Introduction Section -->
        <section class="text-center mb-16">
            <h2 class="text-4xl font-bold text-gray-900 mb-4">From Code to Pixels</h2>
            <p class="max-w-3xl mx-auto text-lg text-gray-600">
                Ever wonder what happens when you load a webpage? It's not magic, but a highly orchestrated process involving multiple components. This guide interactively explores the journey of your code, from a file on a server to a living, breathing page on your screen.
            </p>
        </section>

        <!-- Section 1: Browser Architecture -->
        <section id="architecture" class="mb-20 scroll-mt-20">
            <div class="section-card p-6 md:p-8">
                <h3 class="text-3xl font-bold text-gray-800 mb-2">The Big Picture: Browser Architecture</h3>
                <p class="text-gray-600 mb-8 max-w-4xl">
                    Modern browsers aren't single applications; they're like mini-operating systems. To keep you safe and ensure stability, they use a multi-process architecture. This means different parts of the browser run in isolated, sandboxed processes. Hover over the components below to see how they work together.
                </p>
                <div class="lg:flex lg:space-x-8">
                    <!-- Interactive Diagram -->
                    <div class="lg:w-2/3 grid grid-cols-1 md:grid-cols-2 gap-4" id="architecture-diagram">
                        <div class="interactive-box p-4 rounded-lg border-2 border-gray-200" data-target="browser-process">
                            <h4 class="font-bold text-lg">üß† Browser Process</h4>
                            <p class="text-sm">The "brain" coordinating everything.</p>
                        </div>
                        <div class="interactive-box p-4 rounded-lg border-2 border-gray-200" data-target="renderer-process">
                            <h4 class="font-bold text-lg">üé® Renderer Process</h4>
                            <p class="text-sm">Renders web content in a tab.</p>
                        </div>
                        <div class="interactive-box p-4 rounded-lg border-2 border-gray-200" data-target="gpu-process">
                            <h4 class="font-bold text-lg">üñºÔ∏è GPU Process</h4>
                            <p class="text-sm">Handles graphics tasks.</p>
                        </div>
                         <div class="interactive-box p-4 rounded-lg border-2 border-gray-200" data-target="network-process">
                            <h4 class="font-bold text-lg">üåê Network Process</h4>
                            <p class="text-sm">Manages all internet traffic.</p>
                        </div>
                    </div>
                    <!-- Description Pane -->
                    <div id="architecture-info" class="lg:w-1/3 mt-6 lg:mt-0 p-6 rounded-lg bg-gray-50 border-2 border-dashed border-gray-200 flex items-center justify-center">
                        <div class="text-center">
                            <p class="font-medium text-gray-700">Hover over a process to learn more.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 2: The Twin Engines -->
        <section id="engines" class="mb-20 scroll-mt-20">
            <div class="section-card p-6 md:p-8">
                <h3 class="text-3xl font-bold text-gray-800 mb-2">The Twin Engines of a Web Page</h3>
                <p class="text-gray-600 mb-8 max-w-4xl">
                    Inside each Renderer Process, two specialized engines work together. The **Rendering Engine** builds the page's structure and appearance, while the **JavaScript Engine** executes its logic and interactivity. They are separate but constantly communicating.
                </p>
                <div class="grid md:grid-cols-2 gap-8">
                    <!-- Rendering Engine -->
                    <div>
                        <h4 class="text-2xl font-semibold text-gray-700 mb-4">Blink: The Rendering Engine</h4>
                        <p class="text-gray-600 mb-4">Blink's job is to turn HTML and CSS into pixels on the screen. It follows a clear pipeline:</p>
                        <ul class="space-y-3">
                            <li class="flex items-start">
                                <span class="text-amber-600 font-bold mr-3 mt-1">‚Üí</span>
                                <span><strong>Parse HTML/CSS:</strong> Builds the Document Object Model (DOM) from HTML and the CSS Object Model (CSSOM) from styles.</span>
                            </li>
                            <li class="flex items-start">
                                <span class="text-amber-600 font-bold mr-3 mt-1">‚Üí</span>
                                <span><strong>Render Tree:</strong> Combines the DOM and CSSOM to figure out what needs to be displayed.</span>
                            </li>
                            <li class="flex items-start">
                                <span class="text-amber-600 font-bold mr-3 mt-1">‚Üí</span>
                                <span><strong>Layout:</strong> Calculates the exact size and position of every element.</span>
                            </li>
                             <li class="flex items-start">
                                <span class="text-amber-600 font-bold mr-3 mt-1">‚Üí</span>
                                <span><strong>Paint:</strong> Draws the pixels for each element onto the screen.</span>
                            </li>
                        </ul>
                    </div>
                    <!-- JavaScript Engine -->
                    <div>
                        <h4 class="text-2xl font-semibold text-gray-700 mb-4">V8: The JavaScript Engine</h4>
                        <p class="text-gray-600 mb-4">V8's job is to execute JavaScript code as fast as possible. It uses a technique called Just-In-Time (JIT) compilation. Click the steps below to see how it works.</p>
                        <div id="jit-pipeline" class="space-y-2">
                            <div class="jit-step p-3 rounded-md bg-gray-100" data-target="jit-parse">1. Parse Code</div>
                            <div class="jit-step p-3 rounded-md bg-gray-100" data-target="jit-interpret">2. Interpret & Profile (Ignition)</div>
                            <div class="jit-step p-3 rounded-md bg-gray-100" data-target="jit-optimize">3. Optimize (TurboFan)</div>
                            <div class="jit-step p-3 rounded-md bg-gray-100" data-target="jit-deoptimize">4. Deoptimize (If Needed)</div>
                        </div>
                        <div id="jit-info" class="mt-4 p-4 rounded-lg bg-gray-50 text-gray-600 min-h-[100px]">
                            <p>Click a step to see its description.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 3: The DOM Bridge -->
        <section id="bridge" class="mb-20 scroll-mt-20">
            <div class="section-card p-6 md:p-8">
                <h3 class="text-3xl font-bold text-gray-800 mb-2">The Bridge: How JavaScript Commands the DOM</h3>
                <p class="text-gray-600 mb-8 max-w-4xl">
                    If the engines are separate, how does JavaScript change the page? They don't share memory. Instead, the browser provides a bridge: the **Web APIs**. JavaScript doesn't touch the DOM directly; it sends commands through this official API layer.
                </p>
                <div class="grid md:grid-cols-3 gap-6 text-center">
                    <div class="p-6 bg-amber-50 rounded-lg">
                        <h4 class="text-xl font-semibold mb-2">JavaScript Code</h4>
                        <p class="text-gray-600">Your script calls a function like `document.getElementById()`.</p>
                    </div>
                    <div class="flex items-center justify-center">
                        <span class="text-4xl font-mono text-amber-600">‚Üí</span>
                    </div>
                    <div class="p-6 bg-amber-50 rounded-lg">
                        <h4 class="text-xl font-semibold mb-2">Web API (The Bridge)</h4>
                        <p class="text-gray-600">The browser translates this call into a command for the Rendering Engine.</p>
                    </div>
                </div>
                 <div class="text-center my-4">
                     <span class="text-4xl font-mono text-amber-600">‚Üì</span>
                 </div>
                 <div class="p-6 bg-blue-50 rounded-lg text-center max-w-md mx-auto">
                    <h4 class="text-xl font-semibold mb-2">DOM Manipulation</h4>
                    <p class="text-gray-600">The Rendering Engine modifies the DOM, and schedules a repaint to show the change.</p>
                </div>
                <h4 class="text-2xl font-semibold text-gray-700 mt-12 mb-4 text-center">A Tale of Two Heaps</h4>
                <p class="text-gray-600 mb-8 max-w-4xl mx-auto text-center">
                    This separation extends to memory. JavaScript objects and DOM elements live in different memory "heaps," managed by separate but coordinated Garbage Collectors.
                </p>
                <div class="grid md:grid-cols-2 gap-8 max-w-4xl mx-auto">
                    <div class="p-4 border rounded-lg">
                        <h5 class="font-bold text-lg">V8 Heap (JavaScript)</h5>
                        <p class="text-sm text-gray-600">Managed by the **Orinoco** GC. Stores JS objects, arrays, functions, etc. References to DOM nodes are just lightweight "wrapper" objects here.</p>
                    </div>
                    <div class="p-4 border rounded-lg">
                        <h5 class="font-bold text-lg">Blink Heap (Native C++)</h5>
                        <p class="text-sm text-gray-600">Managed by the **Oilpan** GC. Stores the actual DOM nodes. This is where the real structure of the page lives.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 4: Execution Flow -->
        <section id="execution" class="mb-16 scroll-mt-20">
            <div class="section-card p-6 md:p-8">
                <h3 class="text-3xl font-bold text-gray-800 mb-2">The Execution Flow</h3>
                <p class="text-gray-600 mb-8 max-w-4xl">
                    JavaScript is single-threaded, meaning it can only do one thing at a time. To prevent the UI from freezing, browsers use an **Event Loop** to handle asynchronous tasks like timers or network requests. TypeScript adds a safety layer on top of this, but it's all plain JavaScript by the time it runs.
                </p>
                <!-- Event Loop -->
                <div>
                    <h4 class="text-2xl font-semibold text-gray-700 mb-4">The Event Loop Explained</h4>
                    <div class="flex border border-gray-200 rounded-lg p-1 bg-gray-100 max-w-md mx-auto mb-6">
                        <button class="tab-button flex-1 p-2 rounded-md text-sm font-medium" data-target="macrotask">Macrotasks</button>
                        <button class="tab-button flex-1 p-2 rounded-md text-sm font-medium" data-target="microtask">Microtasks</button>
                    </div>
                    <div id="event-loop-info" class="grid md:grid-cols-2 gap-8 items-center">
                        <!-- Info will be injected here -->
                    </div>
                </div>
                <!-- TypeScript -->
                <div class="mt-12 pt-8 border-t border-gray-200">
                    <h4 class="text-2xl font-semibold text-gray-700 mb-4">The TypeScript Layer</h4>
                    <p class="text-gray-600 mb-6 max-w-4xl">
                        TypeScript doesn't change how browsers work. It's a development tool that adds type safety. Your `.ts` files are **transpiled** into standard `.js` files, with all type information erased, before the browser ever sees them. It's a pre-flight check, not a new runtime.
                    </p>
                    <div class="grid md:grid-cols-3 gap-6 text-center items-center">
                        <div class="p-4 bg-blue-100 rounded-lg">
                            <h5 class="font-bold">Your Code (`.ts`)</h5>
                            <code class="text-sm">const name: string = "World";</code>
                        </div>
                         <div class="flex items-center justify-center">
                            <span class="text-2xl font-mono text-gray-500">Transpiles to ‚Üí</span>
                        </div>
                        <div class="p-4 bg-green-100 rounded-lg">
                             <h5 class="font-bold">Browser-Ready Code (`.js`)</h5>
                            <code class="text-sm">const name = "World";</code>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 5: Detailed View -->
        <section id="detailed-view" class="mb-16 scroll-mt-20">
            <div class="section-card p-6 md:p-8">
                <h3 class="text-3xl font-bold text-gray-800 mb-6">Detailed View: The Full Article</h3>
                <p class="text-gray-600 mb-8 max-w-4xl">
                    For those who want to dive deeper, the complete text from the original report is included below. Click on any section title to expand it.
                </p>
                <div class="space-y-4" id="accordion-container">
                    <!-- Accordion items will be injected here -->
                </div>
            </div>
        </section>

    </main>
    
    <footer class="text-center py-8 border-t border-gray-200">
        <p class="text-gray-500">An interactive visualization based on browser runtime principles.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- SMOOTH SCROLL & ACTIVE NAV LINK ---
            const navLinks = document.querySelectorAll('.nav-link');
            const sections = document.querySelectorAll('section');

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        navLinks.forEach(link => {
                            link.classList.remove('active');
                            if (link.getAttribute('href').substring(1) === entry.target.id) {
                                link.classList.add('active');
                            }
                        });
                    }
                });
            }, { rootMargin: "-50% 0px -50% 0px" });

            sections.forEach(section => {
                observer.observe(section);
            });
            
            navLinks.forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    const targetElement = document.querySelector(this.getAttribute('href'));
                    if (targetElement) {
                        targetElement.scrollIntoView({
                            behavior: 'smooth'
                        });
                    }
                });
            });

            // --- ARCHITECTURE DIAGRAM INTERACTIVITY ---
            const architectureDiagram = document.getElementById('architecture-diagram');
            const architectureInfo = document.getElementById('architecture-info');
            const interactiveBoxes = document.querySelectorAll('.interactive-box');
            
            const architectureInfoContent = {
                'browser-process': {
                    title: 'üß† Browser Process',
                    text: 'The master coordinator. It manages the UI (tabs, address bar), handles network requests and file access, and creates/manages all other processes. It is the only process with full system privileges.'
                },
                'renderer-process': {
                    title: 'üé® Renderer Process',
                    text: 'Where the magic happens for a single tab. It\'s a sandboxed environment that contains the Rendering Engine (Blink) and JavaScript Engine (V8) to parse and render HTML/CSS and execute JS.'
                },
                'gpu-process': {
                    title: 'üñºÔ∏è GPU Process',
                    text: 'Handles all graphics-related tasks, communicating with the computer\'s GPU. This isolation prevents buggy graphics drivers from crashing the entire browser.'
                },
                'network-process': {
                    title: 'üåê Network Process',
                    text: 'Manages all internet communication, like HTTP requests. Running this in a separate process enhances security by isolating it from web content.'
                }
            };

            if (architectureDiagram) {
                architectureDiagram.addEventListener('mouseover', (e) => {
                    const box = e.target.closest('.interactive-box');
                    if (!box) return;

                    const targetId = box.dataset.target;
                    const content = architectureInfoContent[targetId];
                    
                    interactiveBoxes.forEach(b => b.classList.remove('highlight'));
                    box.classList.add('highlight');

                    architectureInfo.innerHTML = `
                        <div class="text-left">
                            <h4 class="font-bold text-lg mb-2">${content.title}</h4>
                            <p class="text-gray-600">${content.text}</p>
                        </div>
                    `;
                });

                architectureDiagram.addEventListener('mouseout', () => {
                     interactiveBoxes.forEach(b => b.classList.remove('highlight'));
                     architectureInfo.innerHTML = `
                        <div class="text-center">
                            <p class="font-medium text-gray-700">Hover over a process to learn more.</p>
                        </div>
                    `;
                });
            }

            // --- JIT PIPELINE INTERACTIVITY ---
            const jitPipeline = document.getElementById('jit-pipeline');
            const jitInfo = document.getElementById('jit-info');
            const jitSteps = document.querySelectorAll('.jit-step');

            const jitInfoContent = {
                'jit-parse': 'The engine first reads the raw JavaScript code and builds a structured representation of it called an Abstract Syntax Tree (AST).',
                'jit-interpret': 'V8\'s interpreter, Ignition, walks the AST and generates bytecode. While executing this bytecode, it gathers profiling data about which functions are "hot" (run often) and what types of data they use.',
                'jit-optimize': 'For "hot" functions, the optimizing compiler, TurboFan, uses the profiling data to generate highly-optimized, speculative machine code that runs much faster.',
                'jit-deoptimize': 'If a speculative assumption proves wrong (e.g., a function optimized for numbers receives a string), the optimized code is thrown away, and execution falls back to the slower bytecode to ensure correctness.'
            };

            if (jitPipeline) {
                jitPipeline.addEventListener('click', (e) => {
                    const step = e.target.closest('.jit-step');
                    if (!step) return;
                    
                    const targetId = step.dataset.target;
                    const content = jitInfoContent[targetId];

                    jitSteps.forEach(s => s.classList.remove('active'));
                    step.classList.add('active');

                    jitInfo.innerHTML = `<p>${content}</p>`;
                });
            }

            // --- EVENT LOOP INTERACTIVITY ---
            const tabButtons = document.querySelectorAll('.tab-button');
            const eventLoopInfo = document.getElementById('event-loop-info');
            
            const eventLoopContent = {
                macrotask: {
                    title: 'Macrotasks (or Tasks)',
                    text: 'These are tasks like `setTimeout`, user interactions (clicks), and I/O. The Event Loop picks up **one** macrotask from the queue per "tick," but only after the microtask queue is completely empty.',
                    diagram: `
                        <div class="p-4 bg-gray-50 rounded-lg border">
                            <div class="font-bold mb-2">Event Loop Tick</div>
                            <div class="p-2 bg-red-100 rounded mb-2">1. Is Call Stack empty? Yes.</div>
                            <div class="p-2 bg-blue-100 rounded mb-2">2. Run ALL microtasks.</div>
                            <div class="p-2 bg-green-100 rounded font-bold border-2 border-green-500">3. Run ONE macrotask.</div>
                        </div>
                    `
                },
                microtask: {
                    title: 'Microtasks',
                    text: 'These have higher priority. They include Promise callbacks (`.then`, `.catch`) and `queueMicrotask`. After a task finishes, **all** microtasks in the queue are executed before the browser does anything else, including rendering or running the next macrotask.',
                     diagram: `
                        <div class="p-4 bg-gray-50 rounded-lg border">
                            <div class="font-bold mb-2">Event Loop Tick</div>
                            <div class="p-2 bg-red-100 rounded mb-2">1. Is Call Stack empty? Yes.</div>
                            <div class="p-2 bg-blue-100 rounded font-bold border-2 border-blue-500">2. Run ALL microtasks.</div>
                            <div class="p-2 bg-green-100 rounded">3. Run ONE macrotask.</div>
                        </div>
                    `
                }
            };
            
            function updateEventLoopTab(targetId) {
                if (!eventLoopInfo) return;
                const content = eventLoopContent[targetId];
                eventLoopInfo.innerHTML = `
                    <div>
                        <h5 class="text-xl font-semibold text-gray-700 mb-3">${content.title}</h5>
                        <p class="text-gray-600">${content.text}</p>
                    </div>
                    ${content.diagram}
                `;
                tabButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.target === targetId);
                });
            }

            tabButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    updateEventLoopTab(e.target.dataset.target);
                });
            });

            // --- ACCORDION FOR DETAILED ARTICLE ---
            const articleContent = [
                {
                    title: "Introduction",
                    content: `
                        <div class="prose max-w-none">
                            <p>The modern web browser has evolved far beyond its origins as a simple document viewer. It now functions as a sophisticated, multi-layered application platform, a veritable operating system for the web, capable of running complex, interactive applications that rival their desktop counterparts. This transformation is predicated on a complex and highly optimized internal architecture designed to solve a fundamental and perilous challenge: securely executing untrusted code downloaded from the internet on a user's local machine. At the heart of this architecture lies the intricate relationship between the code that defines a web page's structure (HTML), its style (CSS), and its dynamic behavior (JavaScript or TypeScript).</p>
                            <p>Understanding how a browser brings a web page to life requires moving beyond the surface of application-level programming and delving into the system's core mechanics. This report provides an exhaustive, "under-the-hood" exploration of this client-side runtime environment. It deconstructs the architectural principles that ensure security and stability, examines the specialized engines that process code and content, and maps the precise communication channels that connect them. The journey will proceed from the high-level, multi-process blueprint of a modern browser to the execution lifecycle of a single line of JavaScript.</p>
                            <p>This analysis will systematically address the foundational questions at the heart of client-side scripting. It will clarify the distinct roles of the primary browser components‚Äîthe Browser Process, the sandboxed Renderer Process, the JavaScript Engine, and the Rendering Engine‚Äîand detail how they coexist and communicate. It will then uncover the specific interface mechanism through which JavaScript code gains access to and manipulates the Document Object Model (DOM), the memory model that governs JavaScript objects and DOM elements, and the end-to-end process a script undergoes from its inclusion in a file to the visual changes it precipitates on the screen. Finally, it will situate TypeScript within this ecosystem, explaining its role as a static analysis layer and its transpilation into the JavaScript that ultimately powers the dynamic web.</p>
                        </div>
                    `
                },
                {
                    title: "The Modern Browser's Architectural Blueprint",
                    content: `
                        <div class="prose max-w-none">
                            <p>To comprehend how JavaScript interacts with the system, one must first understand the system itself. The architecture of a modern web browser is the foundational context upon which all client-side execution is built. It is a design forged by the dual pressures of performance and security, resulting in a complex, multi-process model that isolates components to protect the user and ensure a stable experience.</p>
                            <h3>From Monolith to Multi-Process: The Evolution for Security and Stability</h3>
                            <p>Early web browsers operated as monolithic, single-process applications. In this model, all components‚Äîthe user interface, the HTML rendering logic, the JavaScript interpreter, and all browser tabs‚Äîshared a single operating system process and address space. While sufficient for the static documents of the early web, this architecture proved dangerously fragile and insecure as web pages evolved into complex, code-driven applications. A single bug or infinite loop in a web page's JavaScript could freeze or crash the entire browser, taking all open tabs with it. More critically, a security vulnerability exploited in one tab could grant an attacker access to the entire process, potentially compromising data from other tabs or the user's system.</p>
                            <p>The paradigm shift came with the development of the Chromium project, which introduced a multi-process architecture modeled after modern operating systems. Just as an operating system isolates applications like a word processor and a music player into separate processes, a multi-process browser isolates individual web pages and browser components. This design provides three fundamental advantages that are now standard across major browsers:</p>
                            <ul>
                                <li><strong>Security:</strong> Untrusted code from a website is executed within a heavily restricted, sandboxed process. This "walling off" of web content severely limits an attacker's ability to harm the host system, even if they successfully exploit a vulnerability within the page.</li>
                                <li><strong>Stability and Fault Tolerance:</strong> A crash within a single tab's process is contained. Instead of the entire browser terminating, the user is typically presented with a "sad tab" or equivalent error message for the single failed page, while all other tabs and the main browser interface remain fully functional.</li>
                                <li><strong>Performance and Responsiveness:</strong> The operating system can schedule different browser processes across multiple CPU cores, allowing for true parallelism. A computationally intensive script in one tab will not freeze the browser's user interface or make other tabs unresponsive, as they are running in separate processes.</li>
                            </ul>
                            <h3>Anatomy of a Chromium-based Browser</h3>
                            <p>The multi-process model is not a simple duplication of the browser for each tab. It is a sophisticated division of labor among several types of specialized processes, each with a distinct role and privilege level. The architectural paradigm of the modern browser closely mirrors that of a microkernel operating system. The Browser Process functions as the privileged kernel, managing core system services, while Renderer Processes are akin to user-space applications running with limited privileges.</p>
                            <table>
                                <thead>
                                    <tr><th>Process Type</th><th>Primary Role</th><th>Key Responsibilities</th><th>Security Context</th></tr>
                                </thead>
                                <tbody>
                                    <tr><td><strong>Browser Process</strong></td><td>Main application coordinator; the "brain" of the browser.</td><td>Manages UI (windows, tabs, address bar), handles user input, coordinates network requests and file access. Manages the lifecycle of all other processes.</td><td><strong>Privileged.</strong> Has direct access to the operating system.</td></tr>
                                    <tr><td><strong>Renderer Process</strong></td><td>Renders web page content for a specific tab or site.</td><td>Parses HTML/CSS, executes JavaScript, constructs the DOM. Houses the Rendering Engine (Blink) and JavaScript Engine (V8).</td><td><strong>Sandboxed.</strong> Low-privilege; cannot directly access network, file system, or devices. All such requests are brokered by the Browser Process via IPC.</td></tr>
                                    <tr><td><strong>GPU Process</strong></td><td>Manages GPU tasks for all tabs.</td><td>Handles hardware-accelerated rendering, 3D graphics (WebGL), and video decoding. Communicates with the system's graphics drivers.</td><td><strong>Sandboxed.</strong> Isolated to prevent GPU driver bugs from compromising the system.</td></tr>
                                    <tr><td><strong>Network Service</strong></td><td>Manages all network traffic for the browser.</td><td>Handles HTTP/HTTPS requests, DNS resolution, cookies, and caching.</td><td><strong>Sandboxed.</strong> Runs in its own utility process for security isolation.</td></tr>
                                    <tr><td><strong>Extension Process</strong></td><td>Runs a specific browser extension.</td><td>Executes the extension's background scripts and logic.</td><td><strong>Sandboxed.</strong> Each extension is isolated in its own process with permissions defined in its manifest.</td></tr>
                                    <tr><td><strong>Utility Process</strong></td><td>A generic process for running untrusted or risky tasks.</td><td>Used for tasks like parsing untrusted data, audio processing, etc., that can be safely isolated from the main Browser Process.</td><td><strong>Highly Sandboxed.</strong> Can be configured with very specific, minimal privileges.</td></tr>
                                </tbody>
                            </table>
                            <h3>Inter-Process Communication (IPC): The Browser's Nervous System</h3>
                            <p>Because operating systems enforce strict memory isolation between processes, these disparate browser components cannot communicate by directly accessing each other's memory. Instead, they rely on a formal Inter-Process Communication (IPC) mechanism. In Chromium, this is primarily handled by a system called Mojo, which allows for structured messages to be passed between processes over dedicated channels, often implemented using OS-level named pipes.</p>
                        </div>
                    `
                },
                {
                    title: "The Twin Engines of the Renderer Process",
                    content: `
                        <div class="prose max-w-none">
                            <p>Within the confines of each sandboxed Renderer Process, two highly specialized software components work in tandem to transform abstract code and markup into a tangible, interactive web page. These are the Rendering Engine and the JavaScript Engine. Their relationship is one of close collaboration but strict architectural separation, a "separation of concerns" that is an imperative for both performance and maintainability. The Rendering Engine's domain is structure, layout, and pixels, while the JavaScript Engine's domain is logic, data, and execution. This division allows each engine to be optimized independently and is the reason a formal interface must exist to bridge their two worlds.</p>
                            <h3>The Rendering Engine (e.g., Blink): Architect of the Visual Page</h3>
                            <p>The primary job of the Rendering Engine‚Äîalso known as a layout or browser engine‚Äîis to transform HTML documents and their associated resources (CSS, images) into an interactive visual representation on the user's screen. The process of rendering a page involves several distinct stages.</p>
                            <ul>
                                <li><strong>Parsing HTML to DOM:</strong> The engine parses the HTML markup, tokenizing the tags, attributes, and content. From these tokens, it constructs a tree-like data structure in memory called the <strong>Document Object Model (DOM)</strong>.</li>
                                <li><strong>Parsing CSS to CSSOM:</strong> Simultaneously, the engine parses any CSS it finds, whether in <code>&lt;style&gt;</code> tags or external stylesheets. It builds a corresponding tree structure called the <strong>CSS Object Model (CSSOM)</strong>.</li>
                                <li><strong>Constructing the Render Tree:</strong> The engine combines the DOM and CSSOM to create a <strong>Render Tree</strong>. This new tree is a visual representation of the document; it includes only the elements that will actually be displayed on the page.</li>
                                <li><strong>Layout (or Reflow):</strong> The engine traverses the Render Tree and calculates the precise geometry for each node. This stage determines the exact size and position of every element on the screen.</li>
                                <li><strong>Painting:</strong> Finally, the engine takes the geometric information from the layout stage and "paints" the nodes onto the screen, converting the abstract layout tree into actual pixels.</li>
                            </ul>
                            <h3>The JavaScript Engine (e.g., V8): The Engine of Interactivity</h3>
                            <p>Working alongside the Rendering Engine is the JavaScript Engine, a distinct and separate program designed for one purpose: to execute JavaScript code with maximum performance. The JavaScript Engine itself has no innate knowledge of the DOM, CSS, or any other browser-specific concept.</p>
                            <ul>
                                <li><strong>The Memory Heap:</strong> A large, mostly unstructured region of memory where all dynamic data‚Äîobjects, arrays, and functions‚Äîis allocated.</li>
                                <li><strong>The Call Stack:</strong> A Last-In, First-Out (LIFO) data structure that tracks function execution. JavaScript's single-threaded nature means it has only one Call Stack.</li>
                            </ul>
                            <h3>The Just-In-Time (JIT) Compilation Pipeline</h3>
                            <p>To bridge the performance gap between a high-level, dynamic language like JavaScript and low-level machine code, modern engines employ a sophisticated technique called Just-In-Time (JIT) compilation. The pipeline consists of several stages:</p>
                            <ul>
                                <li><strong>Parsing:</strong> The engine's parser first consumes the raw JavaScript source code and builds an <strong>Abstract Syntax Tree (AST)</strong>.</li>
                                <li><strong>Ignition (Interpreter):</strong> The AST is then passed to V8's interpreter, named <strong>Ignition</strong>. Ignition walks the AST and generates a stream of <strong>bytecode</strong>. While executing, it collects profiling data about the code's runtime behavior.</li>
                                <li><strong>TurboFan (Optimizing Compiler):</strong> When a function becomes "hot," Ignition sends the function's bytecode along with the collected profiling data to V8's optimizing compiler, <strong>TurboFan</strong>. TurboFan uses this feedback to make speculative assumptions and generate highly optimized, specialized native machine code.</li>
                                <li><strong>Deoptimization:</strong> If a speculative assumption made by TurboFan is later violated, the optimized machine code is immediately discarded. Execution seamlessly falls back to the original, unoptimized bytecode to ensure correctness.</li>
                            </ul>
                        </div>
                    `
                },
                {
                    title: "The Interface: How JavaScript Commands the DOM",
                    content: `
                        <div class="prose max-w-none">
                            <p>The architectural separation of the JavaScript Engine and the Rendering Engine raises the central question: if they are distinct systems, how does JavaScript code gain access to and manipulate the DOM? The answer lies not in direct memory access, but in a well-defined, formal API layer that acts as a bridge between the two worlds.</p>
                            <h3>Web APIs: The Official Communication Channel</h3>
                            <p>The bridge that connects the JavaScript runtime to the browser's native capabilities, including the DOM, is a vast set of <strong>Web APIs</strong>. These APIs are not part of the core JavaScript language as defined by the ECMAScript specification. Instead, they are additional functionalities provided by the "host environment"‚Äîin this case, the web browser.</p>
                            <p>When a developer writes <code>document.getElementById('my-element')</code>, they are not executing a command that is native to the JavaScript language. They are invoking a Web API function that the browser has exposed to the JavaScript engine's global scope. Under the hood, this function call is a gateway that crosses the boundary from the JavaScript Engine into the Rendering Engine.</p>
                            <h3>Global Objects as Entry Points: The <code>window</code> and <code>document</code> Objects</h3>
                            <ul>
                                <li><strong>The <code>window</code> Object:</strong> This is the ultimate global object in a browser context. It represents the browser tab or window that contains the DOM document. It is the home for APIs that relate to the browser frame itself, such as <code>setTimeout()</code>, <code>fetch()</code>, and <code>localStorage</code>.</li>
                                <li><strong>The <code>document</code> Object:</strong> This object is a property of the <code>window</code> object. It represents the DOM of the page loaded within that window. The <code>document</code> object is the gateway to the entire content of the page and provides the fundamental methods for DOM manipulation, such as <code>document.createElement()</code> and <code>document.querySelector()</code>.</li>
                            </ul>
                            <h3>Under the Hood: Web IDL and the V8 Bindings Layer</h3>
                            <p>The concrete, low-level mechanism that connects the C++ implementation of the DOM inside Blink to the JavaScript objects developers interact with is defined using the <strong>Web Interface Definition Language (Web IDL)</strong>. During the browser's compilation, a specialized tool called a <strong>bindings generator</strong> processes these IDL files. It automatically generates thousands of lines of C++ "glue code." This generated code is the V8 binding layer, and it handles the marshalling of data across the V8/Blink boundary, manages object lifecycles, and performs type checking.</p>
                        </div>
                    `
                },
                {
                    title: "Memory Management: A Tale of Two Heaps",
                    content: `
                        <div class="prose max-w-none">
                            <p>The memory model of a web browser is a direct and necessary consequence of its dual-engine architecture. Because the JavaScript Engine and the Rendering Engine are separate systems, they maintain separate memory spaces, each managed by its own highly specialized garbage collector.</p>
                            <h3>The JavaScript Heap vs. Native DOM Objects: A Crucial Distinction</h3>
                            <ul>
                                <li><strong>The V8 Heap (JavaScript Heap):</strong> All objects created directly by JavaScript code are allocated here. This includes objects, arrays, functions, and strings. This entire memory space is under the exclusive control of the V8 engine and its garbage collector.</li>
                                <li><strong>Blink's Memory (Native Heap):</strong> DOM nodes, such as those created by <code>document.createElement('div')</code>, are not JavaScript objects. They are complex C++ objects that live in the memory space managed by the Rendering Engine (Blink).</li>
                            </ul>
                            <p>The connection between these two heaps is made via <strong>wrapper objects</strong> or <strong>handles</strong>. When a script obtains a reference to a DOM node, the variable holds a small JavaScript wrapper object on the V8 heap. This wrapper contains a pointer or reference to the actual C++ DOM object residing in Blink's memory.</p>
                            <h3>V8's Garbage Collector (Orinoco) and Blink's Garbage Collector (Oilpan)</h3>
                            <p>V8 employs a garbage collector named <strong>Orinoco</strong>, while Blink has its own, <strong>Oilpan</strong>. Both are state-of-the-art, trace-based garbage collectors that use parallel, concurrent, and incremental techniques to minimize "stop-the-world" pauses that would freeze the application.</p>
                            <h3>The Unified Heap: Coordinated Garbage Collection</h3>
                            <p>The existence of two separate heaps with references pointing between them presents a classic garbage collection problem. The solution is the <strong>unified heap</strong>, a system where the two garbage collectors cooperate through <strong>cross-component tracing</strong>. When a garbage collection cycle begins, V8's GC traces its heap. When it finds a wrapper pointing to a DOM node, it notifies Oilpan. Oilpan then traces its heap, and if it finds a DOM node with an event listener pointing to a JS function, it notifies V8. This cooperative tracing ensures that the entire, combined object graph is traversed correctly, preventing memory leaks caused by cross-heap cycles.</p>
                        </div>
                    `
                },
                {
                    title: "The Execution Model: From Code to Pixels",
                    content: `
                        <div class="prose max-w-none">
                            <p>Synthesizing the architectural, interfacing, and memory management principles allows for a complete, end-to-end understanding of how a script's journey translates into dynamic page updates. This process involves a synchronous execution phase and an asynchronous model governed by the Event Loop.</p>
                            <h3>The Asynchronous Model and the Event Loop</h3>
                            <p>The single-threaded nature of JavaScript presents a significant challenge: any long-running task would block the main thread, freezing the entire user interface. To solve this, the browser environment implements an asynchronous, event-driven concurrency model, with the <strong>Event Loop</strong> at its core.</p>
                            <p>The key components of this model are:</p>
                            <ul>
                                <li><strong>The Call Stack:</strong> Where all synchronous JavaScript code is executed.</li>
                                <li><strong>Web APIs:</strong> When an asynchronous function like <code>setTimeout()</code> is called, the V8 engine hands the operation off to the browser's native Web API implementations, which are often backed by separate browser threads.</li>
                                <li><strong>Task Queues:</strong> When a Web API operation completes, it places a <strong>callback function</strong> into one of two queues:
                                    <ul>
                                        <li><strong>The Task Queue (or Macrotask Queue):</strong> For events like <code>setTimeout</code>, user interactions, and I/O.</li>
                                        <li><strong>The Microtask Queue:</strong> A higher-priority queue for the results of Promises (<code>.then()</code>) and callbacks scheduled with <code>queueMicrotask</code>.</li>
                                    </ul>
                                </li>
                                <li><strong>The Event Loop:</strong> A perpetual process that checks if the Call Stack is empty. If it is, it first executes <strong>all</strong> tasks in the Microtask Queue. Only then will it take a <strong>single</strong> task from the Macrotask Queue to execute.</li>
                            </ul>
                        </div>
                    `
                },
                {
                    title: "The TypeScript Layer: Static Types Above the Dynamic Core",
                    content: `
                        <div class="prose max-w-none">
                            <p>TypeScript does not introduce a new runtime environment or alter the fundamental mechanics of the browser. Instead, it operates entirely as a "pre-flight check" system for JavaScript. It is a development-time tool that adds a layer of static type analysis on top of the existing JavaScript ecosystem, with the goal of improving code quality, maintainability, and developer productivity.</p>
                            <h3>The Transpilation Process: From <code>.ts</code> to Browser-Ready <code>.js</code></h3>
                            <p>Web browsers do not execute TypeScript code directly. To be run in a browser, TypeScript code must first be converted into standard, universally compatible JavaScript. This source-to-source conversion process is known as <strong>transpilation</strong>.</p>
                            <p>The TypeScript compiler (<code>tsc</code>) performs this conversion. A fundamental part of this stage is <strong>type erasure</strong>: all TypeScript-specific syntax, such as type annotations (<code>: string</code>), interfaces, and type aliases, is completely removed from the output. This is because these constructs have no semantic meaning in standard JavaScript; their only purpose was to inform the static analysis phase.</p>
                            <h3>TypeScript and the DOM: Type Definitions for Safe API Interaction</h3>
                            <p>TypeScript does not change <em>how</em> JavaScript interacts with the DOM; it uses the exact same Web APIs. Its contribution is to make this interaction type-safe. This is achieved through a comprehensive set of <strong>type definition files</strong> (<code>.d.ts</code>) that are bundled with the TypeScript compiler, such as <code>lib.dom.d.ts</code>. These files act as a detailed API contract for the entire browser environment, allowing the compiler to provide rich autocompletion and issue compile-time errors if a developer attempts to misuse a DOM API.</p>
                        </div>
                    `
                }
            ];

            const accordionContainer = document.getElementById('accordion-container');
            if (accordionContainer) {
                articleContent.forEach((item, index) => {
                    const accordionItem = document.createElement('div');
                    accordionItem.className = 'border border-gray-200 rounded-lg';
                    
                    accordionItem.innerHTML = `
                        <button class="accordion-button w-full flex justify-between items-center p-4 text-left font-semibold text-lg text-gray-700 hover:bg-gray-50">
                            <span>${item.title}</span>
                            <svg class="w-5 h-5 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                        </button>
                        <div class="accordion-content px-4 pb-4">
                            ${item.content}
                        </div>
                    `;
                    accordionContainer.appendChild(accordionItem);
                });

                accordionContainer.addEventListener('click', (e) => {
                    const button = e.target.closest('.accordion-button');
                    if (button) {
                        const content = button.nextElementSibling;
                        const isOpen = button.classList.contains('open');
                        
                        // Close all open accordions
                        document.querySelectorAll('.accordion-button.open').forEach(openButton => {
                            if (openButton !== button) {
                                openButton.classList.remove('open');
                                openButton.nextElementSibling.style.maxHeight = null;
                            }
                        });

                        // Toggle the clicked one
                        button.classList.toggle('open', !isOpen);
                        if (!isOpen) {
                            content.style.maxHeight = content.scrollHeight + "px";
                        } else {
                            content.style.maxHeight = null;
                        }
                    }
                });
            }

            // Initial state
            updateEventLoopTab('macrotask');
            if (jitSteps.length > 0) {
                jitSteps[0].click(); // Show first JIT step info
            }
        });
    </script>
</body>
</html>
